# 比較 pass by value / reference / name

##### Date: 2019/March/28

<br>

---


## 60 seconds

#### Subtitle#1

- Bullet points#1

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

- Bullet points#2

Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

<br>

## 60 minutes


首先引用一段螞蟻書裡關於**pass by value** 及 **pass by reference**的內容

#### 5.9 Passing Arguments By Value and By Reference

>When arguments are *passed by value*, a *copy* of the argument’s value
is made and passed to the called function.
>
>Changes to the copy do *not* affect an original
variable’s value in the caller.
>
>When an argument is passed by reference, the caller allows the
called function to *modify* the original variable’s value.
>
>Pass-by-value should be used whenever the called function does not need to modify
the value of the caller’s original variable.
>
>This prevents the accidental **side effects** (variable
modifications) that so greatly hinder the development of correct and reliable software systems.
>
>Pass-by-reference should be used only with *trusted* called functions that need to
modify the original variable.
>
>In C, all arguments are passed by value.
>
> As we’ll see in Chapter 7, it’s possible to **simulate** pass-by-reference by using the *address operator* and the *indirection operator*.


#### 傳值(pass by value)

將變數傳送至函式上對應的參數時,
會將值複製再傳進去.

此時對這些變數的修改並不會影響原本變數的值.
最有名的例子應該就是swap了吧

```go
func swap(x int, y int) {
    var temp int = x
    x = y
    y = temp
}

func main () {
    var x int = 5
    var y int = 10

    swap(x, y)
    fmt.Println(x, y)
    // output: x = 5;
    // y = 10;
}
```

不管在swap()裡面如何對x, y兩個變數做運算, 都不會變更到main這裡的x,y實際值.

#### 傳參考(pass by reference)

若是以傳參考的方式傳遞變數, 則會允許被呼叫的函式去修改變數的原始值.

```go
func swap(x *int, y *int) {
    temp := *x
    *x = *y
    *y = temp
}

func main () {
    var x int = 5
    var y int = 10

    swap(&x, &y)
    fmt.Println(x, y)
    // output: x = 10;
    // y = 5;
}
```

#### 傳名(pass by name)

這個就複雜了一些, 根據[Knuth's GPS に関すること - 名前呼びと Jensen's Device][ref#pass-by-name04]的程式碼來解釋比較容易.
(程式碼部份為了上色功能稍做更改)

```go
func foo(by_name x int, by_name cond bool) {
    while (cond) {
        println(x)
        x = x + 1
    }
}

func main() {
    var a int = 5
    foo(a, a < 10)
    println("---")
    println(a)
}
```

執行結果:

```
5
6
7
8
9
---
10
```

原本的傳值呼叫,

**a < 10**在被傳送進foo()之前就先算出了值(true),

這段程式碼會觸發無窮迴圈.

如果是傳名呼叫的話, 這段條件式foo裡面,

直到開始執行while的時候才去計算 **a < 10**這段條件式, 結果就會像上面的輸出結果一樣了.

更詳細的中文解說可以看看[sunny_gong(simula)的回答][ref#pass-by-name03]:

>call-by-name 源自於 Algol60 這個
古早的程式語言，它定義了兩種參數傳遞方式，
>call-by-value 與 call-by-name，
>
>其中call-by-name 被定義為 Name Replacement：「參數列中的每個參數，如果未指定以
傳值的方式來傳遞，就必須以實際傳入的參數來取代。」
>
>在 Compilers - Principles, Techniques, and Tools 這本書的 7.5 節中，它被解釋為 inline-expansion。
>
>其原因是，以 call-by-name 的方式呼叫函式時，如果在某個參數位置上指定了一個運算式
(expression) 當作參數，那麼這個 expression 會被直接傳入函式裡面進行展開，
>
>所以，這個 expression 是在函式裡面才進行運算的，而不是在參數列中預先計算好它的值再傳
進去。
>
>這就產生了 delayed evaluation (延遲計算) 的效果。
>
>delayed evaluation 的好處是，只有當函式需要某個 expression 參數的值，該 expression 才會被計算，否則就不用了。

英文的介紹可以參考

<br>

---

### PHP裡的pass by reference

可以參考[這一篇][ref#PHP references EN] (或是[簡中翻譯版][ref#PHP references CN])

```php
/**
 * Simple sample
 */
class Sample
{
    protected $value;

    public function __construct(string $value)
    {
        $this->setValue($value);
    }

    public function setValue(string $value)
    {
        $this->value = $value;
    }

    public function getValue()
    {
        echo $this->value . PHP_EOL;
    }
}

function test(Sample $sample)
{
    $sample->setValue("AAA");
    // AAA

    $sample = new Sample("BBB");
    // BBB

    $sample->setValue("CCC");
    // CCC
}

function main()
{
    $prova = new Sample("000");
    // 000

    test($prova);
    // AAA
    // BBB
    // CCC

    $prova->getValue();
    // AAA
}
```


<br>

---


## References

[img#01]: /public/images/folder/file "Image description"

[ref#PHP references CN]: https://learnku.com/laravel/t/9184/php-reference-is-a-pit-please-use-it-carefully "PHP 引用是个坑，请慎用"

[ref#PHP references EN]: http://schlueters.de/blog/archives/125-Do-not-use-PHP-references.html "Do not use PHP references"

[ref#pass-by-name01]: http://www.cs.sfu.ca/~cameron/Teaching/383/PassByName.html "Pass-By-Name Parameter Passing by Robert D. Cameron"

[ref#pass-by-name02]: https://stackoverflow.com/questions/838079/what-is-pass-by-name-and-how-does-it-work-exactly "What is “pass-by-name” and how does it work exactly?"

[ref#pass-by-name03]: http://www.programmer-club.com.tw/showSameTitleN/c/20923.html "Programmer Club - call-by-name by sunny_gong(simula)"

[ref#pass-by-name04]: http://metanest.jp/knuths_gps/ "Knuth's GPS に関すること"

[ref#pass-by-name05]: https://docs.scala-lang.org/tour/by-name-parameters.html "Scala Documentation - BY-NAME PARAMETERS"


<br>

#### 其他參考資料

Deitel, P & Deitel, H (2013). [C How to Program 7th Edition](http://www.deitel.com/Books/C/CHowtoProgram7e/tabid/3635/Default.aspx).

GJLMoTea. (2018). [Call by value, Call by reference (address), Call by name, Call by value and copy restore](https://home.gamer.com.tw/creationDetail.php?sn=4051523). 巴哈姆特.


huli. (2018). [深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？](https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/). TechBridge 技術共筆部落格.

阮一峰. (2015). [尾调用优化](http://www.ruanyifeng.com/blog/2015/04/tail-call.html). 阮一峰的网络日志.

Wikipedia. (2019). [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy). Wikipedia.

Doe, J. (2019). [Book name or reference name](link). StackOverflow.


[Title](href link)